{"uid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler","published":"2020-12-01","author":"Ben Gamari","title":"a concurrent garbage collector for the glasgow haskell compiler","notes":[{"content":"Sometimes I think GHC is a collection of \"this new optimization can only be added if we can pile it on top of the other research papers\"","pageNumber":19,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Whoa, never heard of selector optimization, this is a neat thing.\nAlso makes sense that all those unused pieces can be GC'd\n\nAh, I need to read up on whitehole and blackhole in GHC again, I don't remember. TODO\nWhat's the difference between scavenge and evacuate again?","pageNumber":18,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Aha, SRT is Static Reference Table\n\nNow I need to refresh my understanding of Constant Applicative Forms, I've forgotten what's special about them other than being top level definitions.\n\nWhat is this usage of \"intrusive\" ?","pageNumber":17,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"I've forgotten when snapshots are taken, but this implies multiple GC cycles can occur after a snapshot, right?\n\nWhat's a card table for Array# ?","pageNumber":15,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Ooh, was the block size changed after investigation?\nCan we instrument GHC to see statistics on allocation sizes?\nCan I hack my own GHC to use REALLY LARGE allocations cause I have so much memory?","pageNumber":14,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"where do I find ticket #25 ? Is there a git repo in some forge?\n\nI don't remember what scavenge means in GC, I thought it was deallocating the memory?\nBy context, scavenging is moving an object to 'live' memory?\n\n6. Chaos ensues HAH\n\nThis paper requires that you already understand Cheney-style Scan and Limit pointers.","pageNumber":13,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"I had assumed the nursery had only 0 generation objects, but that's not always the case, I guess?\n\nlooks to me like nursery and non-moving GC are entirely different things that don't touch the same memory, so could even happen in parallel?\noh wait, nursery objects could point to non-moving objects! So, concurrent but not necessarily parallel!\n\nI don't know what Cheney-style scan and limit pointers means.","pageNumber":12,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"oh interesting, the global state of one bit CurMarkEpoch is flipped when the next GC starts. Wait, does this cause problems with parallel GC? Does each 'capability' have its own CurMarkEpoch that only it can see?","pageNumber":11,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"What's an object's SRT for the CAF case?\n\none mark for \"liveness\" and one mark for \"visited in this GC cycle?\n\nWhere does this footnote connect? I don't see it?\nOh, it must be for the line at the top of the page\naddress of o is >= AllocPtrSnap and the object is NOT marked","pageNumber":10,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Ah, footnote 14 explains that well. I was confused.\n\nTODO: read the citations for footnote 13, looks complicated but exciting?","pageNumber":9,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Why are we building a list of segments to be collected from the union of all suballocators FILLED lists?\nIs that the list of data that's no longer used at all?\nOk, data that is live after the mutators are done with their collection is promoted, because it's still alive, and thus no longer in the nursery.\n\n9 each GC thread holds a capability, what is this thing again, and why do they each have their own remembered set?\n\n11 marking stacks before a thread is next scheduled after a snapshot sounds like a good idea? ","pageNumber":8,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Does UpdRemSet build a list of pairs of (previous,current) pointer values?\n\nWhat's a stack mutation? Why do we have to mark stacks eagerly?","pageNumber":7,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"is the FREE list segments that can be handed out to suballocators?\nWhat's the difference between FREE and ACTIVE?\nFREE holds segments, ACTIVE is a list of segments that have unallocated blocks\nWait, ACTIVE is only for a suballocator, FREE is not for a suballocator\nok, this is explained in 2b and 2c\n\nWhere's the end of this bottom of page footnote?","pageNumber":6,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"ok, snapshot the heap and work on that for reachability, hm\n\nallocators for 2^m byte chunks? is this a multiblock allocator?\ninteresting idea for sure","pageNumber":5,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Isn't this additional indirection making your own virtual memory subsystem?","pageNumber":3,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"}]}