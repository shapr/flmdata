{"uid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler","published":"2020-12-01","author":"Ben Gamari","title":"a concurrent garbage collector for the glasgow haskell compiler","notes":[{"content":"I had assumed the nursery had only 0 generation objects, but that's not always the case, I guess?\n\nlooks to me like nursery and non-moving GC are entirely different things that don't touch the same memory, so could even happen in parallel?\noh wait, nursery objects could point to non-moving objects! So, concurrent but not necessarily parallel!","pageNumber":12,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"oh interesting, the global state of one bit CurMarkEpoch is flipped when the next GC starts. Wait, does this cause problems with parallel GC? Does each 'capability' have its own CurMarkEpoch that only it can see?","pageNumber":11,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"What's an object's SRT for the CAF case?\n\none mark for \"liveness\" and one mark for \"visited in this GC cycle?\n\nWhere does this footnote connect? I don't see it?\nOh, it must be for the line at the top of the page\naddress of o is >= AllocPtrSnap and the object is NOT marked","pageNumber":10,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Ah, footnote 14 explains that well. I was confused.\n\nTODO: read the citations for footnote 13, looks complicated but exciting?","pageNumber":9,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Why are we building a list of segments to be collected from the union of all suballocators FILLED lists?\nIs that the list of data that's no longer used at all?\nOk, data that is live after the mutators are done with their collection is promoted, because it's still alive, and thus no longer in the nursery.\n\n9 each GC thread holds a capability, what is this thing again, and why do they each have their own remembered set?\n\n11 marking stacks before a thread is next scheduled after a snapshot sounds like a good idea? ","pageNumber":8,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Does UpdRemSet build a list of pairs of (previous,current) pointer values?\n\nWhat's a stack mutation? Why do we have to mark stacks eagerly?","pageNumber":7,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"is the FREE list segments that can be handed out to suballocators?\nWhat's the difference between FREE and ACTIVE?\nFREE holds segments, ACTIVE is a list of segments that have unallocated blocks\nWait, ACTIVE is only for a suballocator, FREE is not for a suballocator\nok, this is explained in 2b and 2c\n\nWhere's the end of this bottom of page footnote?","pageNumber":6,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"ok, snapshot the heap and work on that for reachability, hm\n\nallocators for 2^m byte chunks? is this a multiblock allocator?\ninteresting idea for sure","pageNumber":5,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Isn't this additional indirection making your own virtual memory subsystem?","pageNumber":3,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"}]}