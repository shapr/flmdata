{"uid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler","published":"2020-12-01","author":"Ben Gamari","title":"a concurrent garbage collector for the glasgow haskell compiler","notes":[{"content":"Why are we building a list of segments to be collected from the union of all suballocators FILLED lists?\nIs that the list of data that's no longer used at all?\nOk, data that is live after the mutators are done with their collection is promoted, because it's still alive, and thus no longer in the nursery.\n","pageNumber":8,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Does UpdRemSet build a list of pairs of (previous,current) pointer values?\n\nWhat's a stack mutation? Why do we have to mark stacks eagerly?","pageNumber":7,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"is the FREE list segments that can be handed out to suballocators?\nWhat's the difference between FREE and ACTIVE?\nFREE holds segments, ACTIVE is a list of segments that have unallocated blocks\nWait, ACTIVE is only for a suballocator, FREE is not for a suballocator\nok, this is explained in 2b and 2c\n\nWhere's the end of this bottom of page footnote?","pageNumber":6,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"ok, snapshot the heap and work on that for reachability, hm\n\nallocators for 2^m byte chunks? is this a multiblock allocator?\ninteresting idea for sure","pageNumber":5,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Isn't this additional indirection making your own virtual memory subsystem?","pageNumber":3,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"}]}