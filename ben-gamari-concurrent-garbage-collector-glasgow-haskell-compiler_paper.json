{"uid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler","published":"2020-12-01","author":"Ben Gamari","title":"a concurrent garbage collector for the glasgow haskell compiler","notes":[{"content":"What's an object's SRT for the CAF case?\n\none mark for \"liveness\" and one mark for \"visited in this GC cycle?","pageNumber":10,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Ah, footnote 14 explains that well. I was confused.\n\nTODO: read the citations for footnote 13, looks complicated but exciting?","pageNumber":9,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Why are we building a list of segments to be collected from the union of all suballocators FILLED lists?\nIs that the list of data that's no longer used at all?\nOk, data that is live after the mutators are done with their collection is promoted, because it's still alive, and thus no longer in the nursery.\n\n9 each GC thread holds a capability, what is this thing again, and why do they each have their own remembered set?\n\n11 marking stacks before a thread is next scheduled after a snapshot sounds like a good idea? ","pageNumber":8,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Does UpdRemSet build a list of pairs of (previous,current) pointer values?\n\nWhat's a stack mutation? Why do we have to mark stacks eagerly?","pageNumber":7,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"is the FREE list segments that can be handed out to suballocators?\nWhat's the difference between FREE and ACTIVE?\nFREE holds segments, ACTIVE is a list of segments that have unallocated blocks\nWait, ACTIVE is only for a suballocator, FREE is not for a suballocator\nok, this is explained in 2b and 2c\n\nWhere's the end of this bottom of page footnote?","pageNumber":6,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"ok, snapshot the heap and work on that for reachability, hm\n\nallocators for 2^m byte chunks? is this a multiblock allocator?\ninteresting idea for sure","pageNumber":5,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"},{"content":"Isn't this additional indirection making your own virtual memory subsystem?","pageNumber":3,"paperuid":"ben-gamari-concurrent-garbage-collector-glasgow-haskell-compiler"}]}