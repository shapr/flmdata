{"uid":"10.1145/3381898.3397214","published":"2020-06-16","author":"Ben Gamari , Laura Dietz","title":"Alligator collector: a latency-optimized garbage collector for functional programming languages","notes":[{"content":"so update remembered set works the way I thought!","pageNumber":7,"paperuid":"10.1145/3381898.3397214"},{"content":"I don't understand how the scan and limit pointers are used to easily find freshly evacuated blocks.","pageNumber":6,"paperuid":"10.1145/3381898.3397214"},{"content":"I'm not clear on whether the mark, sync, and sweep steps can be multiply concurrent or if it's always 1,2,3,4.\nI get the impression it can be 2,3,4 a bunch of times before 1 happens again?\nMaybe not though?\n\nWhat size ranges are used by the Ueno allocator?\n\nAha, Ueno is a generational allocator!\n\nParallelism by idempotent marking\n\nI want to read Ueno's review of this paper!","pageNumber":5,"paperuid":"10.1145/3381898.3397214"},{"content":"Ok, so the update remembered set is roughly a record of incremental changes to the heap graph that will need to be handled later.","pageNumber":4,"paperuid":"10.1145/3381898.3397214"},{"content":"I asked Ben Gamari, said GHC is not yet parallel GC?\nI guess GHC's collector is not the same as Alligator?\n\nHow does hardware transactional memory benefit GC? I gotta check that citation.\n\nIs a write barrier an after hook?\n\nI think of old objects having a thunk, when that thunk is evaluated you get a young object?","pageNumber":3,"paperuid":"10.1145/3381898.3397214"},{"content":"misread as \"we propose a composting garbage collector\"\n\nIs alligator both incremental and concurrent? Sounds like yes?","pageNumber":2,"paperuid":"10.1145/3381898.3397214"}]}